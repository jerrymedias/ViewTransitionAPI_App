{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useNavigate } from \"react-router-dom\";\nexport function useNavigateWithTransition() {\n  _s();\n  const navigate = useNavigate();\n  function transition(route, options = {}) {\n    // Check to see if API is supported and also if skiptransition is disabled\n    if (document.startViewTransition) {\n      console.log(\"StartViewTransitionPresent\");\n\n      //decide whether to use backward transition or forward transition and select the root element\n      //and give it the viewTransitionName which you have decided to use\n      const rootElementRef = document.getElementById(\"root\");\n      rootElementRef.style.viewTransitionName = route === -1 ? \"backward-navigation\" : \"forward-navigation\";\n\n      // start transition\n      console.log(\"StartViewTransitionInvoked\");\n      const viewTransition = document.startViewTransition(function updateCallback() {\n        console.log(\"StartViewTransitionCallbackInvoked\", route);\n\n        //React\n        delete options.skipTransition;\n        navigate(route, options);\n\n        //Angular\n        // this.router.navigateByUrl(route)\n\n        console.log(\"StartViewTransitionCallbackFinished\");\n      });\n      console.log(\"StartViewTransitionReturningAtransitionObject\", viewTransition);\n\n      //The updateCallbackDone read-only property of the ViewTransition interface is a Promise\n      //that fulfills when the promise returned by the document.startViewTransition()'s callback fulfills, or rejects when it rejects.\n      //updateCallbackDone is useful when you don't care about the success/failure of the transition animation, and just want to know if and when the DOM is updated.\n      viewTransition.updateCallbackDone.then(() => {\n        console.log(\"StartViewTransitionUpdateCallbackDone\");\n      });\n\n      // A Promise that fulfills once the pseudo-element tree is created and the transition animation is about to start.\n      viewTransition.ready.then(() => {\n        /// Animate the root's new view\n        console.log(\"StartViewTransitionReady\");\n        window.scrollTo({\n          top: 0,\n          left: 0,\n          behavior: \"auto\"\n        });\n      });\n\n      //A Promise that fulfills once the transition animation is finished, and the new page view is visible and interactive to the user.\n      viewTransition.finished.then(() => {\n        // Clear the temporary tag\n        console.log(\"StartViewTransitionFinished\");\n        if (rootElementRef) rootElementRef.style.viewTransitionName = \"\";\n      });\n\n      //Skip the animation part of the transition.\n      if (options.skipTransition) {\n        viewTransition.skipTransition();\n      }\n    } else {\n      // fallback for old browser\n      console.log(\"StartViewTransitionNotPresent\");\n      delete options.skipTransition;\n      navigate(route, options);\n    }\n  }\n  return transition;\n}\n_s(useNavigateWithTransition, \"CzcTeTziyjMsSrAVmHuCCb6+Bfg=\", false, function () {\n  return [useNavigate];\n});","map":{"version":3,"names":["useNavigate","useNavigateWithTransition","_s","navigate","transition","route","options","document","startViewTransition","console","log","rootElementRef","getElementById","style","viewTransitionName","viewTransition","updateCallback","skipTransition","updateCallbackDone","then","ready","window","scrollTo","top","left","behavior","finished"],"sources":["/Users/ravirajsingh/ViewTransitionApp/src/util/transition.js"],"sourcesContent":["import { useNavigate } from \"react-router-dom\"\n\nexport function useNavigateWithTransition() {\n    const navigate = useNavigate()\n    function transition(route, options = {}) {\n        // Check to see if API is supported and also if skiptransition is disabled\n        if (document.startViewTransition) {\n            console.log(\"StartViewTransitionPresent\")\n\n            //decide whether to use backward transition or forward transition and select the root element\n            //and give it the viewTransitionName which you have decided to use\n            const rootElementRef = document.getElementById(\"root\")\n            rootElementRef.style.viewTransitionName =\n                route === -1 ? \"backward-navigation\" : \"forward-navigation\"\n\n            // start transition\n            console.log(\"StartViewTransitionInvoked\")\n            const viewTransition = document.startViewTransition(function updateCallback() {\n                console.log(\"StartViewTransitionCallbackInvoked\", route)\n\n                //React\n                delete options.skipTransition\n                navigate(route, options)\n\n                //Angular\n                // this.router.navigateByUrl(route)\n\n                console.log(\"StartViewTransitionCallbackFinished\")\n            })\n            console.log(\"StartViewTransitionReturningAtransitionObject\", viewTransition)\n\n            //The updateCallbackDone read-only property of the ViewTransition interface is a Promise\n            //that fulfills when the promise returned by the document.startViewTransition()'s callback fulfills, or rejects when it rejects.\n            //updateCallbackDone is useful when you don't care about the success/failure of the transition animation, and just want to know if and when the DOM is updated.\n            viewTransition.updateCallbackDone.then(() => {\n                console.log(\"StartViewTransitionUpdateCallbackDone\")\n            })\n\n            // A Promise that fulfills once the pseudo-element tree is created and the transition animation is about to start.\n            viewTransition.ready.then(() => {\n                /// Animate the root's new view\n                console.log(\"StartViewTransitionReady\")\n\n                window.scrollTo({ top: 0, left: 0, behavior: \"auto\" })\n            })\n\n            //A Promise that fulfills once the transition animation is finished, and the new page view is visible and interactive to the user.\n            viewTransition.finished.then(() => {\n                // Clear the temporary tag\n                console.log(\"StartViewTransitionFinished\")\n                if (rootElementRef) rootElementRef.style.viewTransitionName = \"\"\n            })\n\n            //Skip the animation part of the transition.\n            if (options.skipTransition) {\n                viewTransition.skipTransition()\n            }\n        } else {\n            // fallback for old browser\n            console.log(\"StartViewTransitionNotPresent\")\n            delete options.skipTransition\n            navigate(route, options)\n        }\n    }\n\n    return transition\n}"],"mappings":";AAAA,SAASA,WAAW,QAAQ,kBAAkB;AAE9C,OAAO,SAASC,yBAAyBA,CAAA,EAAG;EAAAC,EAAA;EACxC,MAAMC,QAAQ,GAAGH,WAAW,CAAC,CAAC;EAC9B,SAASI,UAAUA,CAACC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IACrC;IACA,IAAIC,QAAQ,CAACC,mBAAmB,EAAE;MAC9BC,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;;MAEzC;MACA;MACA,MAAMC,cAAc,GAAGJ,QAAQ,CAACK,cAAc,CAAC,MAAM,CAAC;MACtDD,cAAc,CAACE,KAAK,CAACC,kBAAkB,GACnCT,KAAK,KAAK,CAAC,CAAC,GAAG,qBAAqB,GAAG,oBAAoB;;MAE/D;MACAI,OAAO,CAACC,GAAG,CAAC,4BAA4B,CAAC;MACzC,MAAMK,cAAc,GAAGR,QAAQ,CAACC,mBAAmB,CAAC,SAASQ,cAAcA,CAAA,EAAG;QAC1EP,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAEL,KAAK,CAAC;;QAExD;QACA,OAAOC,OAAO,CAACW,cAAc;QAC7Bd,QAAQ,CAACE,KAAK,EAAEC,OAAO,CAAC;;QAExB;QACA;;QAEAG,OAAO,CAACC,GAAG,CAAC,qCAAqC,CAAC;MACtD,CAAC,CAAC;MACFD,OAAO,CAACC,GAAG,CAAC,+CAA+C,EAAEK,cAAc,CAAC;;MAE5E;MACA;MACA;MACAA,cAAc,CAACG,kBAAkB,CAACC,IAAI,CAAC,MAAM;QACzCV,OAAO,CAACC,GAAG,CAAC,uCAAuC,CAAC;MACxD,CAAC,CAAC;;MAEF;MACAK,cAAc,CAACK,KAAK,CAACD,IAAI,CAAC,MAAM;QAC5B;QACAV,OAAO,CAACC,GAAG,CAAC,0BAA0B,CAAC;QAEvCW,MAAM,CAACC,QAAQ,CAAC;UAAEC,GAAG,EAAE,CAAC;UAAEC,IAAI,EAAE,CAAC;UAAEC,QAAQ,EAAE;QAAO,CAAC,CAAC;MAC1D,CAAC,CAAC;;MAEF;MACAV,cAAc,CAACW,QAAQ,CAACP,IAAI,CAAC,MAAM;QAC/B;QACAV,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAC;QAC1C,IAAIC,cAAc,EAAEA,cAAc,CAACE,KAAK,CAACC,kBAAkB,GAAG,EAAE;MACpE,CAAC,CAAC;;MAEF;MACA,IAAIR,OAAO,CAACW,cAAc,EAAE;QACxBF,cAAc,CAACE,cAAc,CAAC,CAAC;MACnC;IACJ,CAAC,MAAM;MACH;MACAR,OAAO,CAACC,GAAG,CAAC,+BAA+B,CAAC;MAC5C,OAAOJ,OAAO,CAACW,cAAc;MAC7Bd,QAAQ,CAACE,KAAK,EAAEC,OAAO,CAAC;IAC5B;EACJ;EAEA,OAAOF,UAAU;AACrB;AAACF,EAAA,CAhEeD,yBAAyB;EAAA,QACpBD,WAAW;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}